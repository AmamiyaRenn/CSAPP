#! https://zhuanlan.zhihu.com/p/558322020
![image](https://w.wallhaven.cc/full/8x/wallhaven-8xxqk2.jpg)

# CSAPP lab2: bomblab

## 碎碎念

对比 datalab 的重量级的花 3 天，bomblab 我用了 2 天时间写出，相对来说还是比较顺畅的
主要是要学会用 gdb 和 objdump，还有就是要有能根据汇编代码写出伪代码的能力，其余倒是没什么（当然课本要掌握）

## 题目与解法

### phase 1

首先用`objdump -d bomb`打开汇编代码，看到`callq 401338 <strings_not_equal>`，就大概能猜到是调用了一个判断字符串是否相同的函数，而函数调用默认是%rdi/%rsi/%rdx/%rcx...，返回值则是%eax，根据第二句 mov 不难猜出%esi 储存是被比较的字符串的地址，所以通过 gdb 的 examine 指令`x/s 0x402400`(广告一下我写的[gdb 常用指令](https://zhuanlan.zhihu.com/p/558276070))即可知道要输入的值（事实上在 shell 中输入 strings bomb 可以找到有这句话）

答案：`Border relations with Canada have never been better.`

### phase 2

看到`callq 40145c <read_six_numbers>`就可以猜出是要输入六位数字，实际去看函数内部的话也能看到调用了 sscanf 函数并且通过`x/s 0x4025c3`指令能看到`%d %d %d %d %d %d`字符串存在。
所以问题就来到了如何确定这六个数字上面了，说实话这条题意外的卡了我挺久的，主要是不是当时不会用 stepi 和 nexti，且不是很想动手去写出反汇编的 c 语言代码。。。。。。再写出代码后可以发现，事实上这是一个循环体，产生一个 2 的 n 次方的数列，所以答案很明显了

答案：`1 2 4 8 16 32`

### phase 3

在看过`<read_six_numbers>`的代码后看到 sscanf 函数就应该比较敏感了，所以`x/s 0x4025cf`后看到`%d %d`，说明是输入两位数字。
确定了输入后继续往下看，根据书上学过的跳转表相关的知识，看到下面一堆无条件跳转`jmp`，且存在`jmpq *0x402470(,%rax,8)`，并进一步通过`x/8xg 0x402470`指令，发现跳转表的存在
要拆弹，关键在于确定如何绕开`<explode_bomb>`函数，这里我们可以发现只要%eax 与 0xc(%rsp)，通过 x 指令可知即第二个数字，二者要相同，而 rax 即 0x8(%rsp)即第一个数字确定跳转到哪条 mov 指令，所以把两个数字对应起来即可

答案：多个，我填了`1 311`

### phase 4

第四阶段一眼能看出还是输入两个数字，但这个阶段特殊的地方在于存在一个不知道什么意思的函数调用`func4`，看汇编代码的炸弹触发条件是 eax=0 即 func4 返回了 0，所以现在问题在于确定 func4 怎么样才能返回 0
写出函数的 c 伪代码，然后猜值可以得到返回 0 的答案

答案：多个，我填了`0 0`

### phase 5

看到`<strings_not_equal>`立马输入`x/s 0x40245e`，发现被比较的字符串为`flyers`，然后傻乎乎的直接输入，然后`bomb!`
回头仔细从头看，看到`<string_length>`那里与下面这一条，可以确定是输入六位字符，那么接下来的问题就是这六个字符是什么
通过列写中间部分的反汇编 c 语言代码，通过`x/s 0x4024be`，可以知道我们需要做的输入六位字符，然后字符的后 4 位会选中`0x4024be`中的对应位置的字符，比如 0x66 代表输入了`f`，那么就会被这个给定的字符串`maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?`给翻译成第 6 位也就是`r`，所以我们可以通过`flyers`解码出答案

答案：`ionefg`

### phase 6

看到这个阶段的长度就感觉很有挑战性，不过不惊慌，还是一步一步来
首先看到`<read_six_numbers>`，所以是输入六位数字，然后继续向下看，结果是一对跳转与条件跳转， 这样看下去不是办法，所以我们需要给这些东西分个段——因为肯定存在着循环
按照这个思路进行分段，把循环与循环之间分开，然后对每个段落列写 c 语言代码，主要一步步写一定能得到答案
第一段是一个循环嵌套，实现了判断六个数字是不是存在相同值，如果存在就炸，所以我们不能输入相同值
第二段从 0x401153 一直到 0x40116d，是一个单循环，完成了把(%rsp)存的 6 个四字节数据 a[i]改为 7-a[i]的操作
第三段一直到 0x4011a9，比较困难，因为跳转结构非常复杂，但也只能硬着头皮上了；通过阅读代码并列写 c 代码，可以知道里面存在一个奇怪的东西，就是 0x6032d0，这个地址通过`x/s`打开是乱码，所以尝试用`x/12xg`打开，发现里面存在着被特定顺序组织起来的数字，即存在数据结构，分析可知这是个单链表结构体，结构可能如下

```cpp
struct Node
{
    int index;// 序号
    int value;// 被存储的值
    Node *next;// 下一个的地址
}
```

重新分析第三段，还是没啥头绪，所以暂时跳过往下看
第四段到 4011d0，写完 c 语言代码后还是没啥头绪，继续往下看
第五段，也是最后一段，里面出现了炸弹的引爆条件通过列写反汇编代码可以知道是判断链表前后数值大小，如果链表下个节点比上个节点的 value 要大就引爆，所以可以合理猜想上面的段落是为了进行排序，而排序的依据正是我们输入的六个数字，而我们的输入最终能改变链表结构，让链表从大到小排
现在抱着假设回去看第三段，瞬间清晰了起来——0x20(%rsp)往上的 6 个 8 字节存的正是 6 个节点的地址，而这一段就是依据 a[i]来放置地址的位置；如果 a[0]=4，就会被第二段改为 3，然后这里就会让 0x20(%rsp)处的 8 字节存放 0x6032d0 所指向的下个地址的下个地址也就是 0x6032f0，其他的也一样
因为第五段是从 0x20(%rsp)处内容所代表的 Node 开始遍历的，且会遍历 6 次，所以上述操作会导致无法遍历 6 次，所以需要有代码能修改指针指向。有了这个想法，回头看第四段，这不是正好就做了这样的事情吗
所以答案已经很明了了，我们通过 value 大小列出节点序号 3 4 5 6 1 2，所以答案就是用 7 去减去它们

答案：`4 3 2 1 6 5`

## 感悟

1. gdb 确实有用，之前只会在 ide 里用鼠标打断点
2. 有时候必须动点手，比如 phase6，不去写 c 的代码肯定写不出（对于我来说）
3. csapp 的实验挺好玩，这个实验做起来想解谜游戏
